name: Slack Webhook Notification
description: "Send messages to Slack using webhooks with rich formatting and error handling"

inputs:
  webhook_url:
    description: "Slack webhook URL (should be passed from secrets)"
    required: true
  message:
    description: "Message to display"
    required: false
    default: "Notification from GitHub Actions"
  title:
    description: "Title of the Slack message"
    required: false
    default: "GitHub Actions Notification"
  channel:
    description: "Slack channel to send the message to (optional, webhook default will be used if not specified)"
    required: false
    default: "not-gh-act"
  username:
    description: "Username to display in Slack"
    required: false
    default: "GitHub Actions Bot"
  icon_emoji:
    description: "Emoji icon to use in Slack"
    required: false
    default: ":rocket:"
  color:
    description: "Color for the message attachment (good, warning, danger, or hex color)"
    required: false
    default: "good"
  status:
    description: "Status of the build (success, failure, warning, info)"
    required: false
    default: "info"

runs:
  using: "composite"
  steps:
    - name: "Validate webhook URL"
      shell: bash
      run: |
        echo "üîç Validating Slack webhook configuration..."

        if [ -z "${{ inputs.webhook_url }}" ]; then
          echo "‚ùå Error: webhook_url is required"
          exit 1
        fi

        if [[ ! "${{ inputs.webhook_url }}" =~ ^https://hooks.slack.com/services/ ]]; then
          echo "‚ùå Error: Invalid Slack webhook URL format"
          echo "Expected format: https://hooks.slack.com/services/..."
          exit 1
        fi

        echo "‚úÖ Webhook URL validation passed"

    - name: "Prepare Slack message"
      shell: bash
      run: |
        echo "üìù Preparing Slack message..."

        # Set color based on status
        case "${{ inputs.status }}" in
          "success") COLOR="good" ;;
          "failure") COLOR="danger" ;;
          "warning") COLOR="warning" ;;
          *) COLOR="${{ inputs.color }}" ;;
        esac

        # Set emoji based on status
        case "${{ inputs.status }}" in
          "success") EMOJI="‚úÖ" ;;
          "failure") EMOJI="‚ùå" ;;
          "warning") EMOJI="‚ö†Ô∏è" ;;
          *) EMOJI="‚ÑπÔ∏è" ;;
        esac

        # Build JSON payload (matching Slack webhook format)
        PAYLOAD=$(cat <<EOF
        {
          "channel": "${{ inputs.channel }}",
          "username": "${{ inputs.username }}",
          "icon_emoji": "${{ inputs.icon_emoji }}",
          "attachments": [
            {
              "color": "${COLOR}",
              "title": "${EMOJI} ${{ inputs.title }}",
              "text": "${{ inputs.message }}",
              "fields": [
                {
                  "title": "Repository",
                  "value": "${{ github.repository }}",
                  "short": true
                },
                {
                  "title": "Branch",
                  "value": "${{ github.ref_name }}",
                  "short": true
                },
                {
                  "title": "Event",
                  "value": "${{ github.event_name }}",
                  "short": true
                },
                {
                  "title": "Actor",
                  "value": "${{ github.actor }}",
                  "short": true
                },
                {
                  "title": "Workflow",
                  "value": "${{ github.workflow }}",
                  "short": true
                },
                {
                  "title": "Run ID",
                  "value": "<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>",
                  "short": true
                }
              ],
              "footer": "GitHub Actions",
              "footer_icon": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
              "ts": $(date +%s)
            }
          ]
        }
        EOF
        )

        # Save payload to file
        echo "$PAYLOAD" > /tmp/slack_payload.json
        echo "‚úÖ Message prepared successfully"
        echo "üìã Payload preview:"
        echo "$PAYLOAD" | head -10

    - name: "Send Slack notification"
      shell: bash
      run: |
        echo "üöÄ Sending message to Slack..."

        # Method 1: Using JSON payload (current approach)
        HTTP_CODE=$(curl -s -w "%{http_code}" -o /tmp/slack_response.json \
          -X POST \
          -H "Content-Type: application/json" \
          -d @/tmp/slack_payload.json \
          "${{ inputs.webhook_url }}")

        echo "HTTP Status Code: $HTTP_CODE"

        # Check response
        if [ "$HTTP_CODE" -eq 200 ]; then
          echo "‚úÖ Message sent successfully to Slack"
          if [ -n "${{ inputs.channel }}" ]; then
            echo "üìç Channel: ${{ inputs.channel }}"
          fi
          echo "üë§ Username: ${{ inputs.username }}"
          echo "üìù Message: ${{ inputs.message }}"
        else
          echo "‚ùå Failed to send message to Slack"
          echo "üìã Response details:"
          cat /tmp/slack_response.json
          echo ""
          echo "üîç Debugging info:"
          echo "URL: ${{ inputs.webhook_url }}"
          echo "Payload size: $(wc -c < /tmp/slack_payload.json) bytes"
          exit 1
        fi

    - name: "Cleanup temporary files"
      shell: bash
      if: always()
      run: |
        echo "üßπ Cleaning up temporary files..."
        rm -f /tmp/slack_payload.json /tmp/slack_response.json
        echo "‚úÖ Cleanup complete"
